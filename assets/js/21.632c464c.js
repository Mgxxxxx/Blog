(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{391:function(t,s,a){"use strict";a.r(s);var v=a(24),_=Object(v.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"tcp特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp特点"}},[t._v("#")]),t._v(" TCP特点")]),t._v(" "),a("ul",[a("li",[t._v("面向连接的传输协议，使用前需建立连接")]),t._v(" "),a("li",[t._v("面向字节流")]),t._v(" "),a("li",[t._v("提供可靠交付，传送的数据无差错、不丢失、不重复，按序到达")])]),t._v(" "),a("h2",{attrs:{id:"停止等待协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#停止等待协议"}},[t._v("#")]),t._v(" 停止等待协议")]),t._v(" "),a("p",[t._v("发送端发送一个分组后，并不会立刻发送写一个分组，而是等待接收方传回确认后，在发送下一个分组。在传输过程中，难免会有出现差错的情况。")]),t._v(" "),a("p",[t._v("一种是发送方发送的分组并没有发送到接收方，这时候发送方在一定时间内没有收到接收方的确认的话，就会重新发送前面发送的分组。")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/assets/img/Net/tcp-1.jpg"),alt:"tcp-1"}}),t._v(" "),a("p",[t._v("第二种情况是接收方发送的确认丢失了，这时候发送方收不到确认，过了一段时间后，也还是会重传分组，接收方则丢弃重复的报文，并回复确认。")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/assets/img/Net/tcp-2.jpg"),alt:"tcp-2"}}),t._v(" "),a("p",[t._v("还有一种特殊的情况就是，接收方发送的确认会迟到，即接收方发送的确认传输到发送方的时间，大于了传送方最大的等待时间。这时候发送方会重新发送一份分组，因为接收方已经接受过了，所以会丢弃重复的，并发送确认。对于发送方，对于接收方发送的迟到的确认的处理是，收下，但什么也不做。")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/assets/img/Net/tcp-3.jpg"),alt:"tcp-3"}}),t._v(" "),a("p",[t._v("发送方必须要等到确认才能发送下一个分组，这样的效率不高，故现在大多使用的是流水线传输，即发送方可以不用等待等到确认才能发送分组，而是可以连续发送多个分组。使用流水线传输的话，就要使用连续ARQ协议和滑动窗口协议，接下来介绍滑动窗口协议。")]),t._v(" "),a("h2",{attrs:{id:"滑动窗口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口"}},[t._v("#")]),t._v(" 滑动窗口")]),t._v(" "),a("p",[t._v("TCP的滑动窗口是以字节为单位的。现在假定A收到B发来的确认报文段，确认号为31，窗口字节为10。根据这两个数据，A可以构造出自己的发送窗口。")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/assets/img/Net/tcp-4.jpg"),alt:"tcp-4"}}),t._v(" "),a("p",[t._v("发送窗口表示，A可以把发送窗口内的所有数据发送出去。当A收到了B对31号确认，那么A的发送窗口将会向前移动一个单位，即发送窗口范围为32~41。注意：B只能对按序收到的数据中最高序号给出确认，就是说若B收到了32号和33号，但是没收到31号，那么B发送的确认报文段中的确认号只能是31，而不能是32或33。之后收到31号之后，确认号就能改为34。")]),t._v(" "),a("h2",{attrs:{id:"tcp拥塞控制方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp拥塞控制方法"}},[t._v("#")]),t._v(" TCP拥塞控制方法")]),t._v(" "),a("p",[t._v("TCP进行拥塞控制算法有四种：慢开始、拥塞避免、快重传、快恢复")]),t._v(" "),a("h3",{attrs:{id:"慢开始"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#慢开始"}},[t._v("#")]),t._v(" 慢开始")]),t._v(" "),a("p",[t._v("这里首先给出一个公式："),a("code",[t._v("拥塞窗口cwnd每次增加量 = min(N,SMSS)")])]),t._v(" "),a("p",[t._v("N是原先未被确认的，但现在被刚收到的确认报文段所确认的字节。SMSS是发送方最大报文段。这里有一个例子：")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/assets/img/Net/tcp-5.jpg"),alt:"tcp-5"}}),t._v(" "),a("p",[t._v("发送方一开始设置cwnd=1，发送完M1，并收到接收方的确认后，cwnd就增加1，变为2。现在可以发送两个报文M2和M3。又收到接收方对M2和M3的确认后，cwnd就增加2，变为4。现在就可以发送4个报文。之后都是这样，每经过一次传输轮次，拥塞窗口cwnd就增加一倍，但是当大于SMSS后，拥塞窗口每次增加量就只能为SMSS了。")]),t._v(" "),a("h3",{attrs:{id:"拥塞避免"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拥塞避免"}},[t._v("#")]),t._v(" 拥塞避免")]),t._v(" "),a("p",[t._v("为了防止cwnd无限增长而引起网络拥塞，我们需要设置一个慢开始门限ssthresh。")]),t._v(" "),a("ul",[a("li",[t._v("当cwnd < ssthresh，使用慢开始算法")]),t._v(" "),a("li",[t._v("当cwnd = ssthresh，可以使用慢开始算法，也可以使用拥塞避免算法")]),t._v(" "),a("li",[t._v("当cwnd > ssthresh，停止慢开始算法，使用拥塞避免算法")])]),t._v(" "),a("p",[t._v("拥塞避免算法的思路是，让cwnd缓慢增大，每经过一个往返时间RTT就把cwnd加1。")]),t._v(" "),a("h3",{attrs:{id:"快重传"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#快重传"}},[t._v("#")]),t._v(" 快重传")]),t._v(" "),a("p",[t._v("快重传基本过程是接收方收到了M1和M2报文段，但是没有收到M3报文段。然后又收到了M4报文段，则接收方则重复发送对M2的确认，紧接着，接收方有连续收到了M5和M6报文段，接收方仍重复发送对M2的确认，这时，发送方连续收到了3个重复确认，就立马进行重传M3。")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/assets/img/Net/tcp-6.jpg"),alt:"tcp-6"}}),t._v(" "),a("h3",{attrs:{id:"快恢复"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#快恢复"}},[t._v("#")]),t._v(" 快恢复")]),t._v(" "),a("p",[t._v("在快重传之后，发送方知道丢失了报文，而不是网络拥塞，所以不启动慢开始，而执行快恢复算法。快恢复算法即把发送方调整ssthresh = cwnd / 2，同时设置cwnd为ssthresh的值，并开始执行拥塞避免算法。")]),t._v(" "),a("p",[t._v("下图展示了包含慢开始、拥塞避免、快重传和快恢复的一个过程")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/assets/img/Net/tcp-7.jpg"),alt:"tcp-7"}})])}),[],!1,null,null,null);s.default=_.exports}}]);